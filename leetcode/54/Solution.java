import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.SortedSet;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Map.Entry;

class Solution{



    /**
     * DFS
     */
    // List<Integer> res = new ArrayList<>();
    // boolean[][] visited;
    // public List<Integer> spiralOrder(int[][] matrix) {
    //     int m = matrix.length, n = matrix[0].length;
    //     visited = new boolean[m][n];
    //     dfs(matrix, 0, 0, m, n, false); 
    //     return res;
    // }
    
    // public void dfs(int[][] martrix,int i, int j, int m, int n, boolean isGoingUp){
    //     if(i >= m || i < 0 || j >= n || j < 0 || visited[i][j] == true){
    //         return;
    //     }
    //     res.add(martrix[i][j]);
    //     visited[i][j] = true;

    //     if(isGoingUp){
    //         dfs(martrix, i-1, j, m, n, true);
    //     }
    //     dfs(martrix, i, j+1, m, n, false);
    //     dfs(martrix, i+1, j, m, n, false);
    //     dfs(martrix, i, j-1, m, n, false);
    //     dfs(martrix, i-1, j, m, n, true); //往上時,一路到最上方

    // }
    


}